\section{Summary}\label{index_Summary}
Loop\-TK is an object-oriented toolkit for modeling, manipulating, and analyzing proteins. This document describes the design of the toolkit and illustrates how the various operations that can be done on proteins are made efficient.

The core concept underlying the toolkit is the \char`\"{}chain.\char`\"{} A \char`\"{}chain\char`\"{} is a linear sequence of \char`\"{}residues\char`\"{}, where each \char`\"{}residue\char`\"{} can contain an arbitrary number of atoms connected in an arbitrary way. These definitions of \char`\"{}chain\char`\"{} and \char`\"{}residue\char`\"{} are extremely general and can handle a broader class of molecules than just proteins - i.e. molecules that are different from the standard backbone-sidechain structure of proteins.

An important additional layer of abstraction is added between \char`\"{}residues\char`\"{} and \char`\"{}atoms\char`\"{} - the \char`\"{}block\char`\"{}. A residue is composed of an arbitrary amount of blocks, while a block defines an arbitrary amount of atoms. This is done for two reasons. First, there is a lot of overlap between residues in their structure. For example, nearly every residue has a backbone sequence of atoms. Abstraction makes the data structure more efficient. Second, there should be a way to differentiate between different parts of the protein. Additional layer of abstraction allows each block to have \char`\"{}type\char`\"{} associated with it - i.e. backbone and sidechain, which is useful for manipulating specific subsection of the residue.

The toolkit requires all resources to be defined before modeling any molecules. Provided with the toolkit is configuration data for modeling proteins. This data defines all the residues, blocks, and atoms necessary. Loop\-TK uses \char`\"{}hard\char`\"{} sphere model for atoms and assumes that the nuclear arrangement is fixed. Most residues consist of three blocks: the \char`\"{}backbone\char`\"{} block, the \char`\"{}sidechain\char`\"{} block, and a block consisting of the oxygen atom that connects to the backbone. Loop\-TK represents the coordinate of the atoms using relative coordinates. When the protein is initially constructed by connecting block to the next block, homogeneous coordinate matrix is used to transform the local coordinate of the block to the appropriate global position.

Loop\-TK can construct molecules that have predefined positions (currently PDB is supported), or it can be used to construct molecules using only the \char`\"{}typical\char`\"{} structure for each residue. For example, one could construct a protein by specifying a sequence of residue names, and the toolkit will automatically generate positions for all the atoms that correspond to these \char`\"{}typical\char`\"{} structures. These \char`\"{}typical\char`\"{} structures supplied with the toolkit are generated from analyzing the PDB files available on the RSCB website and can be customized by changing the configuration data.

Loop\-TK supports variety of collision detection methods through \doxyref{PSpace\-Manager}{p.}{classPSpaceManager}. Currently, the \char`\"{}grid\char`\"{} method of Halperin and Overmars (1998) is used, whereby the space is subdivided into cubes of equal size, and each atom is placed in the cube which contains the atom's center. Each protein has its own grid data structure, implemented by the \doxyref{PGrid}{p.}{classPGrid} class. The toolkit ensures that the grid is always updated whenever an atom moves so that it is accurate. Since all resources must be defined before usage, the maximum size of an atom is known before creating any grids. The size of the side length of each cube is set to be the maximum diameter of all defined atoms. Therefore, to check if an atom is in collision with another atom, the algorithm must check the cube the atom is in along with the 26 neighboring cubes.

Loop\-TK provides a set of classes corresponding to the configuration data provided. These classes provide additional functionality for handling proteins.\section{Modeling}\label{index_Modeling}
The five core classes for modeling proteins are \doxyref{PAtom}{p.}{classPAtom}, \doxyref{PBond}{p.}{classPBond}, \doxyref{PBlock}{p.}{classPBlock}, \doxyref{PResidue}{p.}{classPResidue}, and \doxyref{PChain}{p.}{classPChain}. Only \doxyref{PChain}{p.}{classPChain} is created directly by a user of the toolkit. A \doxyref{PChain}{p.}{classPChain} must be fully defined before it can be manipulated and analyzed. Defining a \doxyref{PChain}{p.}{classPChain} involves adding residues to the chain with or without forcing the positions of the atoms. The functions for \doxyref{PChain}{p.}{classPChain} construction are:



\begin{Code}\begin{verbatim}void PChain::AddResidue(const string &resName) 
void PChain::AddResidue(const string &resName, const PResidueSpec &resSpec)
\end{verbatim}\end{Code}



A \doxyref{PResidue\-Spec}{p.}{classPResidueSpec} defines position information for a residue. By not providing this, a \doxyref{PChain}{p.}{classPChain} will automatically generate position information for the atoms based on the \char`\"{}typical\char`\"{} structure provided in the configuration data.

Once construction is complete, the \doxyref{PChain}{p.}{classPChain} must be finalized by calling \doxyref{PChain::finalize()}{p.}{classPChain_4cb2a0f087cd2c70dca1349b15c12d53}. Finalization signifies that construction is finished and the chain is ready to be manipulated and analyzed. During finalization, a \doxyref{PChain}{p.}{classPChain} caches the data within the molecule in a number of different ways so that later operations done on the \doxyref{PChain}{p.}{classPChain} are extremely fast. For example, consider the method: 

\begin{Code}\begin{verbatim}PChain::getAtom(string blockType, int i)
\end{verbatim}\end{Code}



This routine selects the atom at the ith index of the array of atoms belonging to blocks with type \char`\"{}block\-Type\char`\"{}, where an atom's position in the array is determined by the order in which the atoms are traversed in a traversal of the chain from start to finish. Instead of doing this traversal each time the method is called, the traversal is done once during finalization and the results are cached, allowing the method to run in O(1) time.

One of the strengths of \doxyref{PChain}{p.}{classPChain} is that it is recursive. Any sequence of residues within a chain is also a chain. This allows Loop\-TK to handle subdivision of the protein efficiently and is used in prioritized constraint satisfaction approach (Dhanik et al 2007) of sampling loop conformation, for example.

For example, suppose we have a \doxyref{PChain}{p.}{classPChain} {\tt c} with 50 residues. To create a subchain from the residues with indexes 10 to 20, use the following: 

\begin{Code}\begin{verbatim}PChain *subchain = new PChain(c, 10, 20)
\end{verbatim}\end{Code}

 A subchain is an additional owner of the same residues - operations which affect the residues affect all owning chains. Subchains have a local view on the residues - in this example, residue 0 in {\tt subchain} is the same as residue 10 in {\tt c}. Because of the recursion, subchains can be created from subchains. Manipulating a subchain will only affect residues within the subchain. There is one constraint on creating subchains: direct children subchains of a chain cannot overlap. For example, the following two lines would cause an error:



\begin{Code}\begin{verbatim}PChain *c2 = new PChain(c, 10, 20);
PChain *c3 = new PChain(c, 15, 17);
\end{verbatim}\end{Code}



However, the following commands would be valid:



\begin{Code}\begin{verbatim}PChain *c2 = new PChain(c, 10, 20);
PChain *c3 = new PChain(c2, 5, 7);
\end{verbatim}\end{Code}



As mentioned before, a \doxyref{PChain}{p.}{classPChain} makes no assumptions on the data within it - it can represent any chain of molecules. To deal with proteins, the \doxyref{PProtein}{p.}{classPProtein} class is provided. \doxyref{PProtein}{p.}{classPProtein} is a subtype of \doxyref{PChain}{p.}{classPChain}, and provides additional methods specific to the configuration data. For example, it has a method for getting the end effectors of a loop, which are the last two atoms of the backbone chain. Likewise, similar classes are provided for the other pieces of \doxyref{PChain}{p.}{classPChain} - i.e. \doxyref{PProtein\-Residue}{p.}{classPProteinResidue} for \doxyref{PResidue}{p.}{classPResidue}.\section{Data}\label{index_Configuration}
All configuration data is stored in the {\tt resources} directory as XML files. This directory includes the following files:\begin{itemize}
\item {\tt atoms.xml:} Defines all atoms that might be needed by Loop\-TK: their name, radius, color, and any other relevant data.\item {\tt blocks.xml:} Defines all blocks used by Loop\-TK. A block is defined by specifying all atoms within the block and their relative positions to each other in a \char`\"{}typical\char`\"{} structure. To differentiate between atoms, each atom must be given an ID (i.e. \char`\"{}CA\char`\"{}, \char`\"{}CB\char`\"{}, or \char`\"{}N\char`\"{}). In addition, it defines which atoms are bonded together and which of those bonds are degrees of freedom.\item {\tt connections.xml:} Defines block connections, which show how to connect two previously defined blocks together. Each block connection indicates which atoms between the blocks are bonded together, and whether those bonds are degrees of freedom. It also defines the relative positions between the blocks in a \char`\"{}typical\char`\"{} structure.\item {\tt residues.xml:} Defines all residues used by Loop\-TK. A residue is defined by specifying which blocks are within the residue, and which blocks are connected together. Each atom in each block must have a unique ID within the whole residue. Additionally, the \char`\"{}core block\char`\"{} must be specified - the block which is used to connect this residue to other residues. Finally, a residue definition must specify the \char`\"{}start atom\char`\"{} - the atom in which traversals of this residue should start.\end{itemize}
\section{Input-Output}\label{index_Input-Output}
Loop\-TK provides the module \doxyref{PDBIO}{p.}{classPDBIO} for creating proteins from PDB files and outputting proteins in memory to to PDB files. For example, to create a protein with the data from {\tt 2CRO.pdb}, use the following code:



\begin{Code}\begin{verbatim}PProtein *p = PDBIO::readFromFile("2CRO.pdb");
\end{verbatim}\end{Code}



Another module for input-output is \doxyref{CS2IO}{p.}{classCS2IO}. A {\tt .cs2} file defines a \char`\"{}chain space\char`\"{}. A chain space is a collection of chains in which each chain is a variation of the others. In particular, each chain closes a particular subchain differently. All atoms outside of that subchain have the same positions for all chains in the chain space. {\tt .cs2} files can be used to store all information about a chain space in a highly memory efficient way.\section{Kinematics}\label{index_Inverse}
A common task to accomplish with Loop\-TK is closing a subchain (making it connect to the rest of the chain). Loop\-TK provides two modules to do this, each using a different algorithm. One module uses Cyclic Coordinate Descent (CCD) (Canutescu, etl 2003), and the classes for doing this are \doxyref{PCCDSolver}{p.}{classPCCDSolver} (for \doxyref{PChain}{p.}{classPChain}) and \doxyref{PProtein\-CCDSolver}{p.}{classPProteinCCDSolver} (for \doxyref{PProtein}{p.}{classPProtein}). The other module uses exact inverse kinematics (Coutsias, etl 2004) and is called \doxyref{PExact\-IKSolver}{p.}{classPExactIKSolver}. 